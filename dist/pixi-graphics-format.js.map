{"version":3,"file":"pixi-graphics-format.js","sources":["../src/GraphicsFormat.ts","../src/index.ts"],"sourcesContent":["/**\n * Parse or serialize PIXI.Graphics objects with `*.pgf` files.\n * @class GraphicsFormat\n * @memberof PIXI\n * @example\n * const app = new PIXI.Application();\n * const graphics = PIXI.GraphicsFormat.parse(\"f #f00 dr 30 10 100 150 c\");\n * app.stage.addChild(graphics);\n */\nexport default class GraphicsFormat {\n\n    /**\n     * The aliases for draw commands\n     * @name PIXI.GraphicsFormat.COMMANDS\n     * @static\n     * @readonly\n     * @type {Object}\n     * @property {string} c Alias for method `closePath`\n     * @property {string} h Alias for method `addHole`\n     * @property {string} m Alias for method `moveTo`\n     * @property {string} l Alias for method `lineTo`\n     * @property {string} q Alias for method `quadraticCurveTo`\n     * @property {string} b Alias for method `bezierCurveTo`\n     * @property {string} f Alias for method `beginFill`\n     * @property {string} s Alias for method `lineStyle`\n     * @property {string} dr Alias for method `drawRect`\n     * @property {string} rr Alias for method `drawRoundedRect`\n     * @property {string} rc Alias for method `drawRoundedRect`\n     * @property {string} dc Alias for method `drawCircle`\n     * @property {string} ar Alias for method `arc`\n     * @property {string} at Alias for method `arcTo`\n     * @property {string} de Alias for method `drawEllipse`\n     */\n    public static COMMANDS: {[id: string]: string} = {\n        c: \"closePath\",\n        h: \"addHole\",\n        m: \"moveTo\",\n        l: \"lineTo\",\n        q: \"quadraticCurveTo\",\n        b: \"bezierCurveTo\",\n        f: \"beginFill\",\n        s: \"lineStyle\",\n        dr: \"drawRect\",\n        rr: \"drawRoundedRect\",\n        rc: \"drawRoundedRect\",\n        dc: \"drawCircle\",\n        ar: \"arc\",\n        at: \"arcTo\",\n        de: \"drawEllipse\",\n    };\n\n    /**\n     * Pattern to check that data is correct format.\n     * @name PIXI.GraphicsFormat.FORMAT\n     * @static\n     * @private\n     * @type {RexExp}\n     * @readonly\n     */\n    private static FORMAT: RegExp = /^((\\s)?(c|h|m|l|q|b|f|s|dr|rr|rc|dc|ar|at|de)(\\s[0-9\\.#\\-a-f]+)*(\\s)?)*$/;\n\n    /**\n     * Pattern to check for valid keys\n     * @name PIXI.GraphicsFormat.VALID_KEYS\n     * @static\n     * @private\n     * @type {RexExp}\n     * @readonly\n     */\n    private static VALID_KEYS: RegExp = /^(c|h|m|l|q|b|f|s|dr|rr|rc|dc|ar|at|de)$/;\n\n    /**\n     * The extension for PIXI Graphics\n     * @readonly\n     * @static\n     * @default 'pgf'\n     */\n    public static get EXTENSION(): string {\n        return \"pgf\";\n    }\n\n    /**\n     * Parse a string as a Graphics Object\n     * @static\n     * @method PIXI.GraphicsFormat.parse\n     * @param {string} contents Commands to draw\n     * @param {PIXI.Graphics} [graphics] Graphics object to use, if none is supplied will create new object.\n     * @return {PIXI.Graphics} New graphics object created\n     * @throws {SyntaxError} Throws error if contents is not well formatted\n     */\n    public static parse(contents: string, graphics: PIXI.Graphics = new PIXI.Graphics()): PIXI.Graphics {\n\n        contents = contents.replace(/\\n/g, \" \");\n\n        if (!this.FORMAT.test(contents)) {\n            throw new SyntaxError(\"Supplied content is invalid GraphicsFormat\");\n        }\n\n        const commands: Array<string|number> = contents.split(\" \");\n        for (let j = 0; j < commands.length; j++) {\n            // Convert all numbers to floats, ignore colors\n            const arg: string = commands[j] as string;\n            if (arg[0] === \"#\") {\n                commands[j] = GraphicsFormat.hexToUint(arg);\n            }\n            else if (!this.VALID_KEYS.test(arg)) {\n                commands[j] = parseFloat(arg);\n            }\n        }\n\n        // Execute the draw commands\n        let currentCommand;\n        const params: Array<string|number> = [];\n        let i = 0;\n        while (i <= commands.length) {\n            const item = commands[i++];\n            let resolvedName: string;\n            if (typeof item === \"string\") {\n                resolvedName = this.COMMANDS[item] || item;\n            }\n            // At the end or at a command\n            if (item === undefined || (graphics as any)[resolvedName]) {\n                // execute command\n                if (currentCommand) {\n                    (graphics as any)[currentCommand].apply(graphics, params);\n                    params.length = 0;\n                }\n                // Same the command for later\n                currentCommand = resolvedName;\n            }\n            else {\n                params.push(item);\n            }\n        }\n        return graphics;\n    }\n\n    /**\n     * Convert the graphic to a string\n     * @static\n     * @method PIXI.GraphicsFormat.stringify\n     * @param {PIXI.Graphics} graphics Object to convert to string\n     * @return {string} Graphic serialized as string\n     */\n    public static stringify(graphics: PIXI.Graphics): string {\n\n        // These are protected, which is why they are cast as 'any'\n        const graphicsData: PIXI.GraphicsData[] = (graphics as any).graphicsData;\n\n        let buffer = \"\";\n        let fillColor = 0x0;\n        let fillAlpha = 1;\n        let lineWidth = 0;\n        let lineColor = 0;\n        let lineAlpha = 1;\n\n        for (let j = 0; j < graphicsData.length; j++) {\n\n            const data = graphicsData[j];\n\n            if (data.fillColor !== fillColor || data.fillAlpha !== fillAlpha) {\n                fillColor = data.fillColor;\n                fillAlpha = data.fillAlpha;\n                buffer += `f #${GraphicsFormat.uintToHex(fillColor)} `;\n                if (fillAlpha !== 1) {\n                    buffer += `${GraphicsFormat.toPrecision(fillAlpha)} `;\n                }\n            }\n            if (data.lineWidth > 0 && (\n                    data.lineWidth !== lineWidth ||\n                    data.lineColor !== lineColor ||\n                    data.lineAlpha !== lineAlpha)) {\n                lineWidth = data.lineWidth;\n                lineColor = data.lineColor;\n                lineAlpha = data.lineAlpha;\n                buffer += `s ${GraphicsFormat.toPrecision(lineWidth)} `;\n                if (lineColor > 0 || lineAlpha !== 1) {\n                    buffer += `#${GraphicsFormat.uintToHex(lineColor)} `;\n                }\n                if (lineAlpha !== 1) {\n                    buffer += `${GraphicsFormat.toPrecision(lineAlpha)} `;\n                }\n            }\n\n            const {shape} = data;\n            const holes: PIXI.Polygon[] = (data as any).holes; // \"holes\" is protected\n\n            if (shape instanceof PIXI.Rectangle) {\n                const x = GraphicsFormat.toPrecision(shape.x);\n                const y = GraphicsFormat.toPrecision(shape.y);\n                const width = GraphicsFormat.toPrecision(shape.width);\n                const height = GraphicsFormat.toPrecision(shape.height);\n                buffer += `dr ${x} ${y} ${width} ${height} c `;\n            }\n            else if (shape instanceof PIXI.Ellipse) {\n                const x = GraphicsFormat.toPrecision(shape.x);\n                const y = GraphicsFormat.toPrecision(shape.y);\n                const width = GraphicsFormat.toPrecision(shape.width);\n                const height = GraphicsFormat.toPrecision(shape.height);\n                buffer += `de ${x} ${y} ${width} ${height} c `;\n            }\n            else if (shape instanceof PIXI.Circle) {\n                const x = GraphicsFormat.toPrecision(shape.x);\n                const y = GraphicsFormat.toPrecision(shape.y);\n                const radius = GraphicsFormat.toPrecision(shape.radius);\n                buffer += `dc ${x} ${y} ${radius} c `;\n            }\n            else if (shape instanceof PIXI.Polygon) {\n\n                const {points} = shape;\n                const len = points.length;\n\n                // Check to see if the path is closed (first point is last point)\n                const closed = points[0] === points[len - 2] && points[1] === points[len - 1];\n                const numPoints = closed && holes.length === 0 ? (len / 2) - 1 : len / 2;\n\n                for (let i = 0; i < numPoints; i++) {\n                    const x = GraphicsFormat.toPrecision(shape.points[i * 2]);\n                    const y = GraphicsFormat.toPrecision(shape.points[(i * 2) + 1]);\n                    buffer += `${i === 0 ? \"m\" : \"l\"} ${x} ${y} `;\n                }\n\n                // Check for holes and add them before closing the path\n                for (let k = 0; k < holes.length; k++) {\n                    const hole = holes[k];\n                    const pts = hole.points.length / 2;\n                    for (let l = 0; l < pts; l++) {\n                        const x = GraphicsFormat.toPrecision(hole.points[l * 2]);\n                        const y = GraphicsFormat.toPrecision(hole.points[(l * 2) + 1]);\n                        buffer += `${l === 0 ? \"m\" : \"l\"} ${x} ${y} `;\n                    }\n                    buffer += \"h \";\n                }\n                if (closed) {\n                    buffer += \"c \";\n                }\n            }\n        }\n        return buffer.trim();\n    }\n\n    /**\n     * Optimize 8 bit colors to be shorthand hex values (e.g., \"#ffcc99\" => \"#fc9\")\n     * @static\n     * @method PIXI.GraphicsFormat.uintToHex\n     * @private\n     * @param {string} hex The hex color\n     * @return {string}\n     */\n    private static uintToHex(color: number): string\n    {\n        let hex: string = color.toString(16);\n        while (hex.length < 6) {\n            hex = `0${hex}`;\n        }\n        return hex.replace(/([a-f0-9])\\1([a-f0-9])\\2([a-f0-9])\\3/, \"$1$2$3\");\n    }\n\n    /**\n     * Middleware to use for PIXI.loader\n     * @static\n     * @method PIXI.GraphicsFormat.middleware\n     * @private\n     * @param {string} contents Commands to draw\n     * @param {PIXI.Graphics} [graphics] Graphics object to use, if none is supplied will create new object.\n     * @return {PIXI.Graphics} New graphics object created\n     */\n    public static middleware(): (resource: PIXI.loaders.Resource, next: () => void) => void {\n        return function graphicsFormatParser(resource: PIXI.loaders.Resource, next: () => void): void {\n            if (resource.extension === \"pgf\") {\n                (resource as any).graphics = GraphicsFormat.parse(resource.data as string);\n            }\n            next();\n        };\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @private\n     * @method PIXI.GraphicsFormat.hexToUint\n     */\n    private static hexToUint(hex: string): number {\n        // Remove the hash\n        hex = hex.substr(1);\n\n        // Convert shortcolors fc9 to ffcc99\n        if (hex.length === 3) {\n            hex = hex.replace(/([a-f0-9])/g, \"$1$1\");\n        }\n        return parseInt(hex, 16);\n    }\n\n    /**\n     * Round a number to decimal places\n     * @method PIXI.GraphicsFormat.toPrecision\n     * @private\n     * @static\n     * @param {number} val Number to round\n     * @param {number} [places=2] Number of decimal places to round to\n     * @return {number} Rounded number\n     */\n    private static toPrecision(val: number, places: number = 2): number {\n        const num = Math.pow(10, places);\n        return Math.round(val * num) / num;\n    }\n}\n","/**\n * Global namespace provided by **pixi.js**\n * @namespace PIXI\n */\nimport GraphicsFormat from \"./GraphicsFormat\";\n\n// Apply to the global loader\nPIXI.loader.use(GraphicsFormat.middleware());\n\n// Apply to all future loaders\nPIXI.loaders.Loader.addPixiMiddleware(GraphicsFormat.middleware);\n\n// Load PGF files as text with XHR\nPIXI.loaders.Resource.setExtensionXhrType(\n    GraphicsFormat.EXTENSION,\n    PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n);\n\nif (!(PIXI as any).GraphicsFormat) {\n    Object.defineProperty(PIXI, \"GraphicsFormat\", {\n        get() {\n            return GraphicsFormat;\n        },\n    });\n}\n\nexport {GraphicsFormat};\n"],"names":["Object","GraphicsFormat","contents","graphics","PIXI","Graphics","replace","this","FORMAT","test","SyntaxError","commands","split","j","length","arg","hexToUint","VALID_KEYS","parseFloat","currentCommand","params","i","item","resolvedName","COMMANDS","undefined","apply","push","graphicsData","buffer","fillColor","fillAlpha","lineWidth","lineColor","lineAlpha","data","uintToHex","toPrecision","shape","holes","Rectangle","x","y","width","height","Ellipse","Circle","radius","Polygon","points","len","closed_1","numPoints","k","hole","pts","l","trim","color","hex","toString","resource","next","extension","parse","substr","parseInt","val","places","num","Math","pow","round","c","h","m","q","b","f","s","dr","rr","rc","dc","ar","at","de","loader","use","middleware","loaders","Loader","addPixiMiddleware","Resource","setExtensionXhrType","EXTENSION","XHR_RESPONSE_TYPE","TEXT","defineProperty","get"],"mappings":"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"}