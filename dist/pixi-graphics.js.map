{"version":3,"file":"pixi-graphics.js","sources":["../src/GraphicsFormat.ts","../src/index.ts"],"sourcesContent":["/**\n * Parse or serialize PIXI.Graphics objects with `*.pgf` files.\n * @class GraphicsFormat\n * @memberof PIXI\n * @example\n * const app = new PIXI.Application();\n * const graphics = PIXI.GraphicsFormat.parse(\"f #f00 dr 30 10 100 150 c\");\n * app.stage.addChild(graphics);\n */\nexport default class GraphicsFormat {\n\n    /**\n     * The aliases for draw commands\n     * @name PIXI.GraphicsFormat.COMMANDS\n     * @static\n     * @type {Object}\n     * @property {string} c closePath\n     * @property {string} h addHole\n     * @property {string} m moveTo\n     * @property {string} l lineTo\n     * @property {string} q quadraticCurveTo\n     * @property {string} b bezierCurveTo\n     * @property {string} f beginFill\n     * @property {string} s lineStyle\n     * @property {string} dr drawRect\n     * @property {string} rr drawRoundedRect\n     * @property {string} rc drawRoundedRect\n     * @property {string} dc drawCircle\n     * @property {string} ar arc\n     * @property {string} at arcTo\n     * @property {string} de drawEllipse\n     */\n    public static COMMANDS: {[id: string]: string} = {\n        c: \"closePath\",\n        h: \"addHole\",\n        m: \"moveTo\",\n        l: \"lineTo\",\n        q: \"quadraticCurveTo\",\n        b: \"bezierCurveTo\",\n        f: \"beginFill\",\n        s: \"lineStyle\",\n        dr: \"drawRect\",\n        rr: \"drawRoundedRect\",\n        rc: \"drawRoundedRect\",\n        dc: \"drawCircle\",\n        ar: \"arc\",\n        at: \"arcTo\",\n        de: \"drawEllipse\",\n    };\n\n    /**\n     * The extension for PIXI Graphics\n     * @readonly\n     * @static\n     * @default 'pgf'\n     */\n    public static get EXTENSION(): string {\n        return \"pgf\";\n    }\n\n    /**\n     * Parse a string as a Graphics Object\n     * @static\n     * @method PIXI.GraphicsFormat.parse\n     * @param {string} contents Commands to draw\n     * @param {PIXI.Graphics} [graphics] Graphics object to use, if none is supplied will create new object.\n     * @return {PIXI.Graphics} New graphics object created\n     */\n    public static parse(contents: string, graphics: PIXI.Graphics = new PIXI.Graphics()): PIXI.Graphics {\n\n        // each shape is a new line\n        const isCommand = /^[a-z]{1,2}$/;\n        const commands: Array<string|number> = contents.split(\" \");\n        for (let j = 0; j < commands.length; j++) {\n            // Convert all numbers to floats, ignore colors\n            const arg: string = commands[j] as string;\n            if (arg[0] === \"#\") {\n                commands[j] = GraphicsFormat.hexToUint(arg);\n            }\n            else if (!isCommand.test(arg)) {\n                commands[j] = parseFloat(arg);\n            }\n        }\n\n        // Execute the draw commands\n        let currentCommand;\n        const params: Array<string|number> = [];\n        let i = 0;\n        while (i <= commands.length) {\n            const item = commands[i++];\n            let resolvedName: string;\n            if (typeof item === \"string\") {\n                resolvedName = GraphicsFormat.COMMANDS[item] || item;\n            }\n            // At the end or at a command\n            if (item === undefined || (graphics as any)[resolvedName]) {\n                // execute command\n                if (currentCommand) {\n                    (graphics as any)[currentCommand].apply(graphics, params);\n                    params.length = 0;\n                }\n                // Same the command for later\n                currentCommand = resolvedName;\n            }\n            else {\n                params.push(item);\n            }\n        }\n        return graphics;\n    }\n\n    /**\n     * Convert the graphic to a string\n     * @static\n     * @method PIXI.GraphicsFormat.stringify\n     * @param {PIXI.Graphics} graphics Object to convert to string\n     * @return {string} Graphic serialized as string\n     */\n    public static stringify(graphics: PIXI.Graphics): string {\n\n        // These are protected, which is why they are cast as 'any'\n        const graphicsData: PIXI.GraphicsData[] = (graphics as any).graphicsData;\n\n        let buffer = \"\";\n        let fillColor = 0x0;\n        let fillAlpha = 1;\n        let lineWidth = 0;\n        let lineColor = 0;\n        let lineAlpha = 1;\n\n        for (let j = 0; j < graphicsData.length; j++) {\n\n            const data = graphicsData[j];\n\n            if (data.fillColor !== fillColor || data.fillAlpha !== fillAlpha) {\n                fillColor = data.fillColor;\n                fillAlpha = data.fillAlpha;\n                buffer += `f #${GraphicsFormat.uintToHex(fillColor)} `;\n                if (fillAlpha !== 1) {\n                    buffer += `${GraphicsFormat.toPrecision(fillAlpha)} `;\n                }\n            }\n            if (data.lineWidth > 0 && (\n                    data.lineWidth !== lineWidth ||\n                    data.lineColor !== lineColor ||\n                    data.lineAlpha !== lineAlpha)) {\n                lineWidth = data.lineWidth;\n                lineColor = data.lineColor;\n                lineAlpha = data.lineAlpha;\n                buffer += `s ${GraphicsFormat.toPrecision(lineWidth)} `;\n                if (lineColor > 0 || lineAlpha !== 1) {\n                    buffer += `#${GraphicsFormat.uintToHex(lineColor)} `;\n                }\n                if (lineAlpha !== 1) {\n                    buffer += `${GraphicsFormat.toPrecision(lineAlpha)} `;\n                }\n            }\n\n            const {shape} = data;\n            const holes: PIXI.Polygon[] = (data as any).holes; // \"holes\" is protected\n\n            if (shape instanceof PIXI.Rectangle) {\n                const x = GraphicsFormat.toPrecision(shape.x);\n                const y = GraphicsFormat.toPrecision(shape.y);\n                const width = GraphicsFormat.toPrecision(shape.width);\n                const height = GraphicsFormat.toPrecision(shape.height);\n                buffer += `dr ${x} ${y} ${width} ${height} c `;\n            }\n            else if (shape instanceof PIXI.Ellipse) {\n                const x = GraphicsFormat.toPrecision(shape.x);\n                const y = GraphicsFormat.toPrecision(shape.y);\n                const width = GraphicsFormat.toPrecision(shape.width);\n                const height = GraphicsFormat.toPrecision(shape.height);\n                buffer += `de ${x} ${y} ${width} ${height} c `;\n            }\n            else if (shape instanceof PIXI.Circle) {\n                const x = GraphicsFormat.toPrecision(shape.x);\n                const y = GraphicsFormat.toPrecision(shape.y);\n                const radius = GraphicsFormat.toPrecision(shape.radius);\n                buffer += `dc ${x} ${y} ${radius} c `;\n            }\n            else if (shape instanceof PIXI.Polygon) {\n\n                const {points} = shape;\n                const len = points.length;\n\n                // Check to see if the path is closed (first point is last point)\n                const closed = points[0] === points[len - 2] && points[1] === points[len - 1];\n                const numPoints = closed && holes.length === 0 ? (len / 2) - 1 : len / 2;\n\n                for (let i = 0; i < numPoints; i++) {\n                    const x = GraphicsFormat.toPrecision(shape.points[i * 2]);\n                    const y = GraphicsFormat.toPrecision(shape.points[(i * 2) + 1]);\n                    buffer += `${i === 0 ? \"m\" : \"l\"} ${x} ${y} `;\n                }\n\n                // Check for holes and add them before closing the path\n                for (let k = 0; k < holes.length; k++) {\n                    const hole = holes[k];\n                    const pts = hole.points.length / 2;\n                    for (let l = 0; l < pts; l++) {\n                        const x = GraphicsFormat.toPrecision(hole.points[l * 2]);\n                        const y = GraphicsFormat.toPrecision(hole.points[(l * 2) + 1]);\n                        buffer += `${l === 0 ? \"m\" : \"l\"} ${x} ${y} `;\n                    }\n                    buffer += \"h \";\n                }\n                if (closed) {\n                    buffer += \"c \";\n                }\n            }\n        }\n        return buffer.trim();\n    }\n\n    /**\n     * Optimize 8 bit colors to be shorthand hex values (e.g., \"#ffcc99\" => \"#fc9\")\n     * @static\n     * @method PIXI.GraphicsFormat.uintToHex\n     * @private\n     * @param {string} hex The hex color\n     * @return {string}\n     */\n    private static uintToHex(color: number): string\n    {\n        let hex: string = color.toString(16);\n        while (hex.length < 6) {\n            hex = `0${hex}`;\n        }\n        return hex.replace(/([a-f0-9])\\1([a-f0-9])\\2([a-f0-9])\\3/, \"$1$2$3\");\n    }\n\n    /**\n     * Middleware to use for PIXI.loader\n     * @static\n     * @method PIXI.GraphicsFormat.middleware\n     * @private\n     * @param {string} contents Commands to draw\n     * @param {PIXI.Graphics} [graphics] Graphics object to use, if none is supplied will create new object.\n     * @return {PIXI.Graphics} New graphics object created\n     */\n    public static middleware(): (resource: PIXI.loaders.Resource, next: () => void) => void {\n        return function graphicsFormatParser(resource: PIXI.loaders.Resource, next: () => void): void {\n            if (resource.extension === \"pgf\") {\n                (resource as any).graphics = GraphicsFormat.parse(resource.data as string);\n            }\n            next();\n        };\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @private\n     * @method PIXI.GraphicsFormat.hexToUint\n     */\n    private static hexToUint(hex: string): number {\n        // Remove the hash\n        hex = hex.substr(1);\n\n        // Convert shortcolors fc9 to ffcc99\n        if (hex.length === 3) {\n            hex = hex.replace(/([a-f0-9])/g, \"$1$1\");\n        }\n        return parseInt(hex, 16);\n    }\n\n    /**\n     * Round a number to decimal places\n     * @method PIXI.GraphicsFormat.toPrecision\n     * @static\n     * @param {number} val Number to round\n     * @param {number} [places=2] Number of decimal places to round to\n     * @return {number} Rounded number\n     */\n    private static toPrecision(val: number, places: number = 2): number {\n        const num = Math.pow(10, places);\n        return Math.round(val * num) / num;\n    }\n}\n","/**\n * Global namespace provided by **pixi.js**\n * @namespace PIXI\n */\nimport GraphicsFormat from \"./GraphicsFormat\";\n\n// Apply to the global loader\nPIXI.loader.use(GraphicsFormat.middleware());\n\n// Apply to all future loaders\nPIXI.loaders.Loader.addPixiMiddleware(GraphicsFormat.middleware);\n\n// Load PGF files as text with XHR\nPIXI.loaders.Resource.setExtensionXhrType(\n    GraphicsFormat.EXTENSION,\n    PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n);\n\nif (!(PIXI as any).GraphicsFormat) {\n    Object.defineProperty(PIXI, \"GraphicsFormat\", {\n        get() {\n            return GraphicsFormat;\n        },\n    });\n}\n\nexport {GraphicsFormat};\n"],"names":["Object","GraphicsFormat","contents","graphics","PIXI","Graphics","isCommand","commands","split","j","length","arg","hexToUint","test","parseFloat","currentCommand","params","i","item","resolvedName","COMMANDS","undefined","apply","push","graphicsData","buffer","fillColor","fillAlpha","lineWidth","lineColor","lineAlpha","data","uintToHex","toPrecision","shape","holes","Rectangle","x","y","width","height","Ellipse","Circle","radius","Polygon","points","len","closed_1","numPoints","k","hole","pts","l","trim","color","hex","toString","replace","resource","next","extension","parse","substr","parseInt","val","places","num","Math","pow","round","c","h","m","q","b","f","s","dr","rr","rc","dc","ar","at","de","loader","use","middleware","loaders","Loader","addPixiMiddleware","Resource","setExtensionXhrType","EXTENSION","XHR_RESPONSE_TYPE","TEXT","defineProperty","get"],"mappings":";;;;;;;;mPASA,kBAAA,cA8QA,MA/NIA,uBAAkBC,mBAAlB,WACI,MAAO,uCAWGA,QAAd,SAAoBC,EAAkBC,gBAAAA,KAA8BC,MAAKC,SAKrE,KAAK,GAFCC,GAAY,eACZC,EAAiCL,EAASM,MAAM,KAC7CC,EAAI,EAAGA,EAAIF,EAASG,OAAQD,IAAK,CAEtC,GAAME,GAAcJ,EAASE,EACd,OAAXE,EAAI,GACJJ,EAASE,GAAKR,EAAeW,UAAUD,GAEjCL,EAAUO,KAAKF,KACrBJ,EAASE,GAAKK,WAAWH,IAQjC,IAHA,GAAII,GACEC,KACFC,EAAI,EACDA,GAAKV,EAASG,QAAQ,CACzB,GAAMQ,GAAOX,EAASU,KAClBE,QACgB,iBAATD,KACPC,EAAelB,EAAemB,SAASF,IAASA,OAGvCG,KAATH,GAAuBf,EAAiBgB,IAEpCJ,IACCZ,EAAiBY,GAAgBO,MAAMnB,EAAUa,GAClDA,EAAON,OAAS,GAGpBK,EAAiBI,GAGjBH,EAAOO,KAAKL,GAGpB,MAAOf,IAUGF,YAAd,SAAwBE,GAYpB,IAAK,GATCqB,GAAqCrB,EAAiBqB,aAExDC,EAAS,GACTC,EAAY,EACZC,EAAY,EACZC,EAAY,EACZC,EAAY,EACZC,EAAY,EAEPrB,EAAI,EAAGA,EAAIe,EAAad,OAAQD,IAAK,CAE1C,GAAMsB,GAAOP,EAAaf,EAEtBsB,GAAKL,YAAcA,GAAaK,EAAKJ,YAAcA,IACnDD,EAAYK,EAAKL,UACjBC,EAAYI,EAAKJ,UACjBF,GAAU,MAAMxB,EAAe+B,UAAUN,OACvB,IAAdC,IACAF,GAAaxB,EAAegC,YAAYN,SAG5CI,EAAKH,UAAY,IACbG,EAAKH,YAAcA,GACnBG,EAAKF,YAAcA,GACnBE,EAAKD,YAAcA,KACvBF,EAAYG,EAAKH,UACjBC,EAAYE,EAAKF,UACjBC,EAAYC,EAAKD,UACjBL,GAAU,KAAKxB,EAAegC,YAAYL,QACtCC,EAAY,GAAmB,IAAdC,KACjBL,GAAU,IAAIxB,EAAe+B,UAAUH,QAEzB,IAAdC,IACAL,GAAaxB,EAAegC,YAAYH,QAIzC,IAAAI,WACDC,EAAyBJ,EAAaI,KAE5C,IAAID,YAAiB9B,MAAKgC,UAKtBX,GAAU,OAJJY,EAAIpC,EAAegC,YAAYC,EAAMG,SACrCC,EAAIrC,EAAegC,YAAYC,EAAMI,SACrCC,EAAQtC,EAAegC,YAAYC,EAAMK,aACzCC,EAASvC,EAAegC,YAAYC,EAAMM,mBAG/C,IAAIN,YAAiB9B,MAAKqC,QAAS,CACpC,GAAMJ,GAAIpC,EAAegC,YAAYC,EAAMG,GACrCC,EAAIrC,EAAegC,YAAYC,EAAMI,GACrCC,EAAQtC,EAAegC,YAAYC,EAAMK,OACzCC,EAASvC,EAAegC,YAAYC,EAAMM,OAChDf,IAAU,MAAMY,MAAKC,MAAKC,MAASC,YAElC,IAAIN,YAAiB9B,MAAKsC,OAI3BjB,GAAU,OAHJY,EAAIpC,EAAegC,YAAYC,EAAMG,SACrCC,EAAIrC,EAAegC,YAAYC,EAAMI,QAC5BrC,EAAegC,YAAYC,EAAMS,kBAG/C,IAAIT,YAAiB9B,MAAKwC,QAAS,CASpC,IAAK,GAPEC,YACDC,EAAMD,EAAOnC,OAGbqC,EAASF,EAAO,KAAOA,EAAOC,EAAM,IAAMD,EAAO,KAAOA,EAAOC,EAAM,GACrEE,EAAYD,GAA2B,IAAjBZ,EAAMzB,OAAgBoC,EAAM,EAAK,EAAIA,EAAM,EAE9D7B,EAAI,EAAGA,EAAI+B,EAAW/B,IAAK,CAChC,GAAMoB,GAAIpC,EAAegC,YAAYC,EAAMW,OAAW,EAAJ5B,IAC5CqB,EAAIrC,EAAegC,YAAYC,EAAMW,OAAY,EAAJ5B,EAAS,GAC5DQ,KAAmB,IAANR,EAAU,IAAM,SAAOoB,MAAKC,MAI7C,IAAK,GAAIW,GAAI,EAAGA,EAAId,EAAMzB,OAAQuC,IAAK,CAGnC,IAAK,GAFCC,GAAOf,EAAMc,GACbE,EAAMD,EAAKL,OAAOnC,OAAS,EACxB0C,EAAI,EAAGA,EAAID,EAAKC,IAAK,CAC1B,GAAMf,GAAIpC,EAAegC,YAAYiB,EAAKL,OAAW,EAAJO,IAC3Cd,EAAIrC,EAAegC,YAAYiB,EAAKL,OAAY,EAAJO,EAAS,GAC3D3B,KAAmB,IAAN2B,EAAU,IAAM,SAAOf,MAAKC,MAE7Cb,GAAU,KAEVsB,IACAtB,GAAU,OAItB,MAAOA,GAAO4B,QAWHpD,YAAf,SAAyBqD,GAGrB,IADA,GAAIC,GAAcD,EAAME,SAAS,IAC1BD,EAAI7C,OAAS,GAChB6C,EAAM,IAAIA,CAEd,OAAOA,GAAIE,QAAQ,uCAAwC,WAYjDxD,aAAd,WACI,MAAO,UAA8ByD,EAAiCC,GACvC,QAAvBD,EAASE,YACRF,EAAiBvD,SAAWF,EAAe4D,MAAMH,EAAS3B,OAE/D4B,MAUO1D,YAAf,SAAyBsD,GAQrB,MAHmB,MAHnBA,EAAMA,EAAIO,OAAO,IAGTpD,SACJ6C,EAAMA,EAAIE,QAAQ,cAAe,SAE9BM,SAASR,EAAK,KAWVtD,cAAf,SAA2B+D,EAAaC,gBAAAA,IACpC,IAAMC,GAAMC,KAAKC,IAAI,GAAIH,EACzB,OAAOE,MAAKE,MAAML,EAAME,GAAOA,GArPrBjE,YACVqE,EAAG,YACHC,EAAG,UACHC,EAAG,SACHpB,EAAG,SACHqB,EAAG,mBACHC,EAAG,gBACHC,EAAG,YACHC,EAAG,YACHC,GAAI,WACJC,GAAI,kBACJC,GAAI,kBACJC,GAAI,aACJC,GAAI,MACJC,GAAI,QACJC,GAAI,mBCxCZ/E,MAAKgF,OAAOC,IAAIpF,EAAeqF,cAG/BlF,KAAKmF,QAAQC,OAAOC,kBAAkBxF,EAAeqF,YAGrDlF,KAAKmF,QAAQG,SAASC,oBAClB1F,EAAe2F,UACfxF,KAAKmF,QAAQG,SAASG,kBAAkBC,MAGtC1F,KAAaH,gBACfD,OAAO+F,eAAe3F,KAAM,kBACxB4F,eACI,MAAO/F"}